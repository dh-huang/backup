# cache consistence

只要使用缓存，一定就会涉及到缓存和数据库**双写一致性问题**；缓存是删除还是更新？先操作缓存还是先操作数据库？

**给缓存设置过期时间，是保证最终一致性的兜底方案；**

#### 更新 VS 删除

两个角度考虑为什么不能使用更新缓存的策略：

1. **数据安全角度：**同时出现了A、B两个请求进行更新数据，那么可能出现以下执行序列：

   ```
   1. A更新数据库
   2. B更新数据库
   3. B更新缓存
   4. A更新缓存
   ```

   那么这样的话，缓存中的就是脏数据了（当然可以使用分布式锁的方式进行并发控制，但是对性能有影响）

2. **业务场景角度：**

   1. 写操作密集，缓存频繁被更新，可能更新了的数据永远都不会读取到
   2. 非写操作密集，但是缓存中的数据是由计算而来，而计算又非常耗时，那么每次更新缓存都得计算一次



#### 缓存更新策略

**先删除缓存，再更新数据库**

出现数据不一致的场景：

1. A请求写，B请求读并发

   ```
   1. A删除缓存
   2. B从缓存读取数据，读取失败，直接从数据库查询并更新缓存，此时数据库中还是旧值
   3. A修改数据库
   ```

2. 数据库读写分离，读从库时数据还未同步完成

**先更新数据库，再删除缓存（Cache-Aside pattern）**

出现数据不一致的场景：

1. A请求写，B请求读并发

   ```
   1. 缓存失效
   2. B请求查询数据，缓存未命中，从数据库中读取到旧值
   3. A请求写入新值到数据库，并删除缓存
   4. B请求将查询到的旧值更新到缓存
   ```

   其实这样的情况出现的频率很低，得A请求写数据库要比B请求读取数据的速度快（读操作必须在写操作之前进入数据库，又必须在写操作之后更新缓存），，，

2. 数据库读写分离，读从库时数据还未同步完成

以上两种方案解决不一致的办法都是：**延时双删**，如果需要提升吞吐量，第二次删除可以做成异步的（线程池、消息队列）；但是如果第二次删除缓存的时候失败了，那么缓存里可能就是脏数据了，解决方案：**重试机制（消息队列的重试、或者JVM自身的重试）**

但是如此以来对业务系统的侵入性就很大，其他的更新方案：

**订阅binlog**

![](./img/cache_consistence_binlog.png)

参考：https://www.cnblogs.com/rjzheng/p/9041659.html



**Read/Write Through Pattern**

即对于调用方来说，就只有一个Repository，数据加载/更新由Repo负责，对调用方是个黑箱；

更新数据的时候，如果命中缓存，则直接更新缓存，再由缓存自己更新数据库（同步操作），如果没有命中缓存，则直接更新数据库；

还是需要结合`cache-aside pattern`的方式？



**Write Behind Caching Pattern**

`write behind`也叫`write back`，其实就是Linux的`Page Cache`算法，更新数据的时候，只更新缓存，然后异步的更新数据库，这样可以让**I/O操作很快，而且可以对数据进行批量合并更新（Lazy的思想）**；

**缺点就是数据不是强一致性的，可能会丢失的；另外就是需要track哪些数据是被更新了的**



**缓存更新失败或者数据库更新失败如何处理**

2PC或者一致性算法(Paxos)，必然会降低吞吐量，为什么不接受最终一致性呢（重试机制）？

参考：https://coolshell.cn/articles/17416.html



**队列串行化**

一定要强一致性的话，那就使用队列串行化的方案；

更新数据时，根据数据的唯一标识（hash），通过路由发送到对应的JVM队列中去，如果查询时缓存未命中，同样根据数据的唯一标识发送查询请求到对应的JVM队列中去；相应的JVM队列对应一个工作线程，工作线程拿到操作请求后，串行的执行相应的操作，对于更新操作就先删除缓存，再更新数据库；

这样的可能存在的问题：

- 读请求长时间阻塞
- 热点数据路由问题，导致请求的倾斜，全部打到一台机器上去了

参考：https://gitee.com/shishan100/Java-Interview-Advanced/blob/master/docs/high-concurrency/redis-consistence.md



**更加复杂的方案**

同样是将请求路由到同一JVM中去，结合**缓存击穿的解决方案**，使用`FutureTask`的方式，所有请求竞争等待同一个`FutureTask`计算完成，只是这里的`FutureTask`的操作是需要加上更新数据的方式；

结合多级缓存？或者使用ZK分布式锁 + `FutureTask`？